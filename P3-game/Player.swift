//  Player.swift
//  P3-game
//
//  Created by Richardier on 27/07/2020.
//  Copyright ¬© 2020 Ianis Richardier. All rights reserved.
//

import Foundation

class Player {
    
    var name = String()
    
    // ‚¨áÔ∏é Tableau contenant les instances de la classe Character, correspondants aux 3 personnages de chaque joueur
    var squad: [Character] = []
    
    // ‚¨áÔ∏é Tableau des personnages morts qui se remplit au fur et √† mesure que les membres du tableau squad sont supprim√©s en jeu.
    var deadSquadMembers: [Character] = []
    

    // ‚¨áÔ∏é Propri√©t√© permettant de garder une r√©f√©rence au character choisi par le joueur pour le round en cours (donne la possibilit√©, entre autres, de jouer avec les valeurs des d√©g√¢ts des armes de chaque character, et de leur redonner une valeur par d√©faut si besoin)
    private var fightingCharacter = Character(name: "")
    
    // ‚¨áÔ∏é La valeur de chestChances d√©terminera si un coffre appara√Æt devant le personnage, ou non.
   private var chestChances = Int()
    
    // ‚¨áÔ∏é Les nouveaux d√©g√¢ts inflig√©s par le h√©ros gr√¢ce √† l'arme trouv√©e dans le coffre.
   private var newDamagesRandom = Int()
    
    // ‚¨áÔ∏é Permet au programme d'aller chercher et d'attaquer l'escouade adverse en changeant l'index du tableau de Players. Elle est statique pour pouvoir l'utiliser dans la classe Game, dans la fonction "startPlaying": on lui ajoute 1 √† chaque tour de boucle "for player in [players]" et lorsque la boucle est termin√©e (signifiant la fin du round 1) et que les deux joueurs ont chacun effectu√© leur action, indexCountHelper est remis √† 0 pour √™tre r√©utilis√© au round suivant.
    static var indexCountHelper = 0
    
    
    // ‚¨áÔ∏é Cr√©ation des escouades de 3 personnages par le joueur. Dans la limite de 3, ajout des instances Character, choix du type de personnage puis d'un nom unique par l'utilisateur.
    func createMySquad() {
        let playableCharacters = [Warrior(), Magus(), Dwarf(), Colossus(), Priest()]
        while squad.count < 3 {
            print("üîî Choisis le personnage numero \(squad.count+1) parmi les suivants :\n")
            for characters in playableCharacters {
                print("\(characters.description)")
            }
            let userInput = readLine()
            let trimmedUserInput = userInput?.trimmingCharacters(in: .whitespaces)
            
            // FIXME: ‚¨áÔ∏é faut-il ajouter un "else" au cas ou l'utilisateur ne renseigne pas une valeur trimm√©e ? Est-ce que le trimming est bien plac√© ?
            if let choice = trimmedUserInput {
                switch choice {
                    /* Chaque cas permet, dans l'ordre :
                     ‚Ä¢ d'ajouter une instance de Character au tableau [squad]
                     ‚Ä¢ d'appeler la fonction chooseName dont le param√®tre correspond au type (Guerrier, Mage, Nain...) respectif de chaque personnage
                     */
                case "1" :
                    squad.append(Warrior())
                    chooseName(of: "Guerrier üë®üèø‚Äç‚öñÔ∏è")
                case "2" :
                    squad.append(Magus())
                    chooseName(of: "Mage üßôüèº‚Äç‚ôÇÔ∏è")
                case "3" :
                    squad.append(Dwarf())
                    chooseName(of: "Nain üë®üèø‚Äçüöí")
                case "4" :
                    squad.append(Colossus())
                    chooseName(of: "Colosse üèãüèª")
                case "5" :
                    squad.append(Priest())
                    chooseName(of: "Pr√™tre üßñüèº‚Äç‚ôÇÔ∏è")
                default: print("ü§ï Merci de taper un chiffre entre 1 et 5 pour choisir le personnage correspondant")
                }
            }
        }
    }
    
    
    // ‚¨áÔ∏é Fonction permettant √† l'utilisateur de choisir un nom unique pour chacun de ses trois personnages.
    private func chooseName(of type: String) {
        print("\nTu as opt√© pour un \(type), choisis-lui un nom üè∑")
        let userInput = readLine()
        if Character.charactersNames.contains(userInput!) { // On v√©rifie dans le tableau r√©capitulatif de tous les noms si ce dernier existe d√©j√†
            print("Ce nom est d√©j√† pris.")
            chooseName(of: type)
        } else { // FIXME: Si on choisit le mage 2 fois, le pr√©nom du deuxi√®me remplacera aussi celui du premier ! + faire en sorte que √ßa d√©balle de mani√®re safe avec trimming
            Character.charactersNames.append(userInput!) // On ajoute la valeur au tableau r√©capitulatif de tous les noms
            squad[squad.count-1].name = userInput! // On assigne √©galement cette valeur √† la propri√©t√© characterName du personnage en question
            print("\nAdjug√© vendu üôå Ton \(type) se nommera \(userInput!) !\n\n")
        }
    }
    
    
    // ‚¨áÔ∏é Fonction permettant √† l'utilisateur de choisir le personnage avec lequel il souhaite effectuer une action pour le round en cours
    func pickFighters() {
        print("üé≤ √âquipe \(name), saisis un chiffre correspondant au personnage avec lequel tu souhaites combattre pendant le round \(Game.roundCount+1) :\n")
        // ‚¨áÔ∏é Affiche une liste des personnages vivants et disponibles dans l'escouade.
        for (index, character) in squad.enumerated() {
            print("\(index+1). \(character.name) le \(character.characterType)\n")
        }
        if let choice = readLine() {
            switch choice {
                // FIXME: ‚¨áÔ∏é Le if squad.indices du "case 1" ci dessous est peut-√™tre facultatif, puisque l'index 0 du tableau squad aura toujours une valeur... sinon c'est que le joueur n'a plus du tout de personnage et c'est la fin de partie.
                
            case "1" : // peut-√™tre qu'utiliser "where" + condition apr√®s chaque "case" est mieux que ".indices.contains()"
                if squad.indices.contains(0) { // ‚Ä£ Permet de s√©curiser la saisie, dans le cas ou l'utilisateur souhaiterait appeler un personnage d√©j√† √©limin√©.
                    fightingCharacter = squad[0] // ‚Ä£ On m√©morise quel personnage va au combat pour ce round
                    print("\nTu as choisi de jouer avec \(squad[0].name), ton \(squad[0].characterType).")
                    chest() // ‚Ä£ √©v√®nement al√©atoire
                } else {
                    print("\nüö£‚Äç‚ôÄÔ∏è Choisis un personnage qui est encore vivant !")
                    pickFighters()
                }
            case "2" :
                if squad.indices.contains(1) {
                    fightingCharacter = squad[1]
                    print("\nTu as choisi de jouer avec \(squad[1].name), ton \(squad[1].characterType).")
                    chest()
                } else {
                    print("\nüö£‚Äç‚ôÄÔ∏è Choisis un personnage qui est encore vivant !")
                    pickFighters()
                }
            case "3" :
                if squad.indices.contains(2) {
                    fightingCharacter = squad[2]
                    print("\nTu as choisi de jouer avec \(squad[2].name), ton \(squad[2].characterType).")
                    chest()
                } else {
                    print("\nüö£‚Äç‚ôÄÔ∏è Choisis un personnage qui est encore vivant !")
                    pickFighters()
                }
            default:
                print("\nüö£‚Äç‚ôÄÔ∏è Ce h√©ros n'existe pas. Tape un chiffre correspondant puis appuie sur 'Entr√©e'.")
                pickFighters()
            }
        }
        
    }
    
    // ‚¨áÔ∏é Fait appara√Ætre un coffre, juste apr√®s que le joueur ait choisi son combattant. 5 fois sur 10. Le coffre contient des armes elfiques de diff√©rents types en fonction des dommages, qui varieront entre 10 et 80. Une arme elfique du m√™me type pourra donc √™tre plus ou moins puissante.
   private func chest() {
        newDamagesRandom = Int.random(in: 10...80) // ‚Ä£ assigne √† la propri√©t√© une nouvelle valeur al√©atoire √† chaque appel de chest()
        chestChances = Int.random(in: 1...10) // ‚Ä£ idem
        if chestChances <= 5 {
            print("\nOh... Les elfes vous ont fait parvenir un coffre üßù‚Äç‚ôÇÔ∏è‚ú®üßù Voyons voir ce qu'il y a dedans... üîç")
            if newDamagesRandom <= 25 {
            print("\nIl contient une dague elfique √©th√©r√©e üó° Celle-ci inflige \(newDamagesRandom) points de d√©g√¢ts !")
                equipChestWeapon() // ‚Ä£ Demande au joueur s'il souhaite √©quiper l'arme trouv√©e
            } else if newDamagesRandom > 25 && newDamagesRandom <= 50 {
                print("\nIl contient une √©p√©e elfique √©th√©r√©e üó° Celle-ci inflige \(newDamagesRandom) points de d√©g√¢ts !")
                equipChestWeapon()
            } else if newDamagesRandom > 50 && newDamagesRandom <= 70 {
                print("\nIl contient un arc elfique √©th√©r√© üèπ Celui-ci inflige \(newDamagesRandom) points de d√©g√¢ts !")
                equipChestWeapon()
            } else {
                print("\nIl contient un b√¢ton de sorcier elfique √©th√©r√© ü¶Ø‚ú® Celui-ci inflige \(newDamagesRandom) points de d√©g√¢ts !")
                equipChestWeapon()
            }
        } else {
            fightingCharacter.weapon.damages = fightingCharacter.defaultCharacterDamages
        }
    }
    
    // ‚¨áÔ∏é M√©thode de confirmation de l'arme elfique
   private func equipChestWeapon() {
        print("\nVeux-tu t'en √©quiper pour ce tour ?\n\n"
        + "1. Oui üôã\n"
        + "2. Non üôÖ")
        if let choice = readLine() {
            switch choice {
            case "1" :
                fightingCharacter.weapon.damages = newDamagesRandom // ‚Ä£ Oui: Les dommages actuels sont remplac√©s
                print("\nTr√®s bien, on la prend ! üéí\n")
            case "2" :
                fightingCharacter.weapon.damages = fightingCharacter.defaultCharacterDamages // ‚Ä£ Non: On r√©attribue les dommages par d√©faut
                print("\nTr√®s bien, on leur retourne le cadeau ! üí®")
            default :
                print("üö£‚Äç‚ôÇÔ∏è Merci de saisir un chiffre correspondant √† Oui ou Non.")
                equipChestWeapon()
            }
        }
    }
    
    func chooseCharacterAction() {
        
        print("üîî Que veux-tu faire ?\n"
            + "\n1. Soigner un alli√© ‚õë"
            + "\n2. Attaquer un membre de l'escouade adverse üî™")
        if let choice = readLine() {
            switch choice {
            case "1" :
                healAlly()
            //  let test = players[indexCountHelper]
            case "2" :
                if Player.indexCountHelper == 0 {
                    attackEnnemy(inTeam: 1)
        // TODO: remplacer index de attackEnnemy par un tableau (player ou autre) ?
                }
                else {
                    attackEnnemy(inTeam: 0)
                }
                
            default: print("üö£‚Äç‚ôÄÔ∏è Merci de taper un chiffre correspondant √† l'une des deux options.")
            chooseCharacterAction()
            }
        }
    }
    
   private func healAlly() {
        
        print("Quel alli√© veux-tu soigner ? üè•\n")
        for (index, character) in squad.enumerated() {
            print("\(index+1). Soigner \(character.name) ton \(character.characterType) (\(character.hp)/\(character.maxHp) hp) \n")
        }
        print("0. Effectuer une autre action üôáüèª‚Äç‚ôÇÔ∏è")
        
        if let choice = readLine() {
            switch choice {
            case "1" :
                heal(characterNumber: 0)
            case "2" :
                heal(characterNumber: 1)
            case "3" :
                heal(characterNumber: 2)
            case "0" :
                chooseCharacterAction() // ‚Ä£ Le joueur peut revenir au menu pr√©c√©dent s'il le souhaite.
                
            default :
                print("\nüö£‚Äç‚ôÇÔ∏è Merci de saisir un chiffre correspondant √† l'un des personnages de ton escouade, ou taper '0' puis 'Entr√©e' pour effectuer une autre action.\n\n")
                healAlly()
            }
            
        }
    }
    
   private func heal(characterNumber: Int) { // ‚Ä£ Lire la fonction avec param√®tre comme suit : "Soigner caract√®re num√©ro: 0, 1 ou 2"
    let target = squad[characterNumber]
        if squad.indices.contains(characterNumber) {
            if target.hp <= target.maxHp - fightingCharacter.healSkill { // ‚Ä£ Si les HP actuels du character cibl√© par le soin ont un √©cart sup√©rieur ou √©gal au montant de la propri√©t√© HealSkill, compar√© √† son maxHP, ajouter ce montant en entier.
                target.hp += fightingCharacter.healSkill
                print("\(target.name) r√©cup√®re \(fightingCharacter.healSkill) points de vie ‚ô•Ô∏è \(target.name) a d√©sormais \(target.hp) hp\n")
            } else if target.hp == target.maxHp { // ‚Ä£ Si les hp actuels du character sont d√©j√† au maximum :
                print("\nüö£‚Äç‚ôÇÔ∏è Ce personnage a d√©j√† le maximum de points de vie. Soigne un autre membre de ton escouade ou effectue une autre action.\n\n")
                healAlly()
            } else { // ‚Ä£ Si les HP actuels du character ont un √©cart inf√©rieur au montant de la comp√©tence healskill, ajouter seulement la diff√©rence pour atteindre le maxHp.
                print("\(target.name) r√©cup√®re \(target.maxHp - target.hp) points de vie ‚ô•Ô∏è")
                target.hp += target.maxHp - target.hp
                print(" \(target.name) a d√©sormais \(target.maxHp) hp\n")
            }
        } else {
            print("üö£‚Äç‚ôÇÔ∏è Bien essay√© ! S√©l√©ctionne un h√©ros vivant.")
            healAlly()
        }
        
    }
    

    
   private func attackEnnemy(inTeam teamIndex: Int) {
        print("\n\nQuel ennemi veux-tu attaquer ? ‚öîÔ∏è\n")
        for (index, character) in game.players[teamIndex].squad.enumerated() {
            print("\(index+1). Attaquer \(character.name) le \(character.characterType) (\(character.hp)/\(character.maxHp) hp)\n")
        }
        print("0. Effectuer une autre action üôáüèª‚Äç‚ôÇÔ∏è")
        
        if let choice = readLine() {
            switch choice {
                // FIXME:
            case "1" : attack(characterNumber: 0, inTeam: teamIndex) // "Attaquer le character num√©ro: 0, dans l'√©quipe: 0 ou 1"
            case "2" : attack(characterNumber: 1, inTeam: teamIndex)
            case "3" : attack(characterNumber: 2, inTeam: teamIndex)
            case "0" : chooseCharacterAction() // ‚Ä£ Le joueur peut revenir au menu pr√©c√©dent s'il le souhaite.
            default: print("üö£‚Äç‚ôÇÔ∏è Merci de saisir un chiffre correspondant √† l'action souhait√©e\n")
            attackEnnemy(inTeam: teamIndex)
            }
            
        }
    }
    // ‚¨áÔ∏é Comme pour la m√©thode heal, la propri√©t√© characterNumber permet d'aller chercher le personnage attaqu√©. La propri√©t√© inTeam, quant √† elle, d√©fini dans quelle √©quipe il faut aller le trouver.
   private func attack(characterNumber: Int, inTeam teamIndex: Int) {
    
        let target = game.players[teamIndex].squad[characterNumber]
    
        if game.players[teamIndex].squad.indices.contains(characterNumber) {
            target.hp -= fightingCharacter.weapon.damages
            print("\nTon h√©ros frappe \(target.name) pour \(fightingCharacter.weapon.damages) de d√©g√¢ts ! üíî\n")
            if target.hp > 0 {
                print("\(target.name) a d√©sormais \(target.hp)/\(target.maxHp) hp\n\n")
            } else {
                print("\(target.name) n'a plus aucun point de vie üíÄ \(target.name) est retir√© de l'escouade !\n\n\n")
                target.hp = 0
                greatReaper(inTeam: teamIndex, characterNumber: characterNumber)
            }
            fightingCharacter.weapon.damages = fightingCharacter.defaultCharacterDamages
            
        } else {
            print("\nüëª Les fant√¥mes ne peuvent pas tenir une arme !\n")
            attackEnnemy(inTeam: teamIndex)
        }
    }
    
    
    // ‚¨áÔ∏é La grande faucheuse retire un personnage sans PdV du tableau des personnages (squad) et ajoute ce dernier au tableau des h√©ros morts (deadSquadMembers).
   private func greatReaper(inTeam teamIndex: Int, characterNumber: Int) {
        game.players[teamIndex].deadSquadMembers.append(game.players[teamIndex].squad[characterNumber])
        game.players[teamIndex].squad.remove(at: characterNumber)
    }
    
}
